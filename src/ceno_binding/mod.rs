mod error;
mod pcs;

use ark_ff::FftField;
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
pub use error::Error;

pub trait PolynomialCommitmentScheme<E: FftField>: Clone {
    type Param: Clone;
    type ProverParam: Clone;
    type VerifierParam: Clone;
    type CommitmentWithData;
    type Commitment: Clone + Default + CanonicalSerialize + CanonicalDeserialize;
    type CommitmentChunk: Clone + Default;
    type Proof: Clone + CanonicalSerialize + CanonicalDeserialize;
    type Poly: Clone;
    type Transcript: Clone;

    fn setup(poly_size: usize) -> Result<Self::Param, Error>;

    fn commit(pp: &Self::ProverParam, poly: &Self::Poly)
        -> Result<Self::CommitmentWithData, Error>;

    fn commit_and_write(
        pp: &Self::ProverParam,
        poly: &Self::Poly,
        transcript: &mut Self::Transcript,
    ) -> Result<Self::CommitmentWithData, Error> {
        let comm = Self::commit(pp, poly)?;
        Self::write_commitment(&Self::get_pure_commitment(&comm), transcript)?;
        Ok(comm)
    }

    fn write_commitment(
        comm: &Self::Commitment,
        transcript: &mut Self::Transcript,
    ) -> Result<(), Error>;

    fn get_pure_commitment(comm: &Self::CommitmentWithData) -> Self::Commitment;

    fn batch_commit(
        pp: &Self::ProverParam,
        polys: &[Self::Poly],
    ) -> Result<Self::CommitmentWithData, Error>;

    fn batch_commit_and_write(
        pp: &Self::ProverParam,
        polys: &[Self::Poly],
        transcript: &mut Self::Transcript,
    ) -> Result<Self::CommitmentWithData, Error> {
        let comm = Self::batch_commit(pp, polys)?;
        Self::write_commitment(&Self::get_pure_commitment(&comm), transcript)?;
        Ok(comm)
    }

    fn open(
        pp: &Self::ProverParam,
        poly: &Self::Poly,
        comm: &Self::CommitmentWithData,
        point: &[E],
        eval: &E,
        transcript: &mut Self::Transcript,
    ) -> Result<Self::Proof, Error>;

    /// This is a simple version of batch open:
    /// 1. Open at one point
    /// 2. All the polynomials share the same commitment.
    /// 3. The point is already a random point generated by a sum-check.
    fn batch_open(
        pp: &Self::ProverParam,
        polys: &[Self::Poly],
        comm: &Self::CommitmentWithData,
        point: &[E],
        evals: &[E],
        transcript: &mut Self::Transcript,
    ) -> Result<Self::Proof, Error>;

    fn verify(
        vp: &Self::VerifierParam,
        comm: &Self::Commitment,
        point: &[E],
        eval: &E,
        proof: &Self::Proof,
        transcript: &mut Self::Transcript,
    ) -> Result<(), Error>;

    fn batch_verify(
        vp: &Self::VerifierParam,
        comm: &Self::Commitment,
        point: &[E],
        evals: &[E],
        proof: &Self::Proof,
        transcript: &mut Self::Transcript,
    ) -> Result<(), Error>;
}
